# include "structural_problem.hpp"

namespace pagmo { namespace problem {

base_ptr structural_problem::clone() const
{
    return base_ptr(new structural_problem(*this));
}


// void structural_problem::compute_constraints_impl(constraint_vector& constraints,
//                                                   const decision_vector& decision) const
// {
//     // The graph representing the structure must have a single
//     // connected component containing all of the nodes with either an
//     // applied load or a boundary condition.

//     // How to check:
//     // -] nr of in/out edges of mandatory vertices must be >= 1
//     // -] graph has to be connected
//     if (!feasible) constraints[0] = 1.;   
// }

void structural_problem::objfun_impl(fitness_vector& fitness,
                                     const decision_vector& genes) const
{
    // MOVE ME SOMWHERE ELSE!! //
    
    // Build structure
    auto structure = structure_t();
    auto element   = element_t{1., 1.};

    // Add vertices keeping track of bcs and loaded related ones
    auto mandatory_vertices = std::vector<eva::index_t>();
    for (const auto& joint : joints_)
    {
        auto vidx = add_vertex(joint, structure);
        
        // Store mandatory vertex index
        if (joint.bcs  != decltype(joint.bcs) ::Zero()
            ||
            joint.load != decltype(joint.load)::Zero())
            mandatory_vertices.emplace_back(vidx);
    }
    
    for (auto node_it = 0u; node_it < gene_mask_.size(); ++node_it)
        for (auto link_it = 0u; link_it < gene_mask_[node_it].size(); ++link_it)
        {
            auto src = node_it;
            auto trg = gene_mask_[node_it][link_it];
            add_edge(src, trg, element, structure);
            // std::cout
            //     << " Adding edge: "
            //     << structure[src].coords.transpose()
            //     << " -- "
            //     << structure[trg].coords.transpose()
            //     << std::endl;
        }
    
    // Check for structure feasibility:
    auto feasible = true;
    // -] check that each mandatory vertices has at least one edge
    for (const auto v_idx : mandatory_vertices)
    {
        if (out_degree(v_idx, structure) == 0)
        {
            feasible = false;
            break;
        }    
    }
    // -] check that the graph representing the structure is connected
    feasible = feasible && eva::utils::is_connected(structure);
    
    if (feasible)
    {
        // Setup solver and solve
        auto results = solve(structure, eva::sparse_solver_params<>());
    
        // Compute compliance
        auto n_nodes    = num_vertices(structure);
        auto compliance = 0.;
        for (size_t vidx = 0u; vidx < n_nodes; ++vidx)
            compliance += structure[vidx].load.transpose() * results[vidx].displacement;    

        // Set fitness equal to compliance
        fitness[0] = compliance;
    }
    else
        // Set the predefined unfeasible value
        fitness[0] = UNFEASIBLE_SCENARIO_FITNESS;
}

}} // end namespaces 
